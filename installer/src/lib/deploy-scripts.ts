import { SSHClient } from './ssh-client';
import { DeploymentConfig } from './types';

// GitHub repo URL for cloning
const REPO_URL = 'https://github.com/Mariosat15/NewsPortal.git';

// Node.js version to install (use LTS)
const NODE_VERSION = '20';

export type DeploymentStepId = 'connect' | 'prepare' | 'upload' | 'env' | 'deps' | 'build' | 'nginx' | 'ssl' | 'start';

export interface StepUpdate {
  stepId: DeploymentStepId;
  status: 'running' | 'completed' | 'error';
  message?: string;
  log?: string;
  complete?: boolean;
  error?: string;
}

type ProgressCallback = (update: StepUpdate) => void;

// Helper to check if command succeeded
function checkSuccess(result: { exitCode: number; stdout: string; stderr: string }, operation: string): void {
  if (result.exitCode !== 0) {
    throw new Error(`${operation} failed: ${result.stderr || result.stdout}`);
  }
}

export function generateEnvFile(config: DeploymentConfig): string {
  return `# ============================================
# NEWS PORTAL - ${config.domain.brandName}
# Brand ID: ${config.domain.brandId}
# Generated by Installer: ${new Date().toISOString()}
# ============================================

# Brand Configuration
BRAND_ID=${config.domain.brandId}
BRAND_NAME="${config.domain.brandName}"
BRAND_DOMAIN=${config.domain.domain}
BRAND_LOGO_URL=/images/brands/${config.domain.brandId}/logo.svg
BRAND_PRIMARY_COLOR=${config.domain.primaryColor}
BRAND_SECONDARY_COLOR=${config.domain.secondaryColor}

# MongoDB
MONGODB_URI=${config.database.mongodbUri}

# Authentication
BETTER_AUTH_SECRET=${config.admin.authSecret}
BETTER_AUTH_URL=https://${config.domain.domain}

# DIMOCO Payment
DIMOCO_API_URL=${config.payment.dimocoApiUrl}
DIMOCO_API_KEY=${config.payment.dimocoApiKey}
DIMOCO_MERCHANT_ID=${config.payment.dimocoMerchantId}
DIMOCO_SERVICE_ID=${config.payment.dimocoServiceId}
DIMOCO_CALLBACK_SECRET=${config.payment.dimocoCallbackSecret}
DIMOCO_SUCCESS_URL=https://${config.domain.domain}/payment/success
DIMOCO_CANCEL_URL=https://${config.domain.domain}/payment/cancel

# Article pricing
ARTICLE_PRICE_CENTS=${config.payment.articlePriceCents}

# OpenAI
OPENAI_API_KEY=${config.apiKeys.openaiApiKey}

# BrightData (optional)
${config.apiKeys.brightdataToken ? `BRIGHTDATA_API_TOKEN=${config.apiKeys.brightdataToken}` : '# BRIGHTDATA_API_TOKEN='}
${config.apiKeys.brightdataZone ? `BRIGHTDATA_ZONE=${config.apiKeys.brightdataZone}` : '# BRIGHTDATA_ZONE=web_unlocker1'}

# Admin Configuration
ADMIN_EMAIL=${config.admin.adminEmail}
ADMIN_PASSWORD=${config.admin.adminPassword}
ADMIN_SECRET=${config.admin.adminSecret}

# Agent Configuration
AGENT_CRON_SCHEDULE=0 */6 * * *
AGENT_MAX_ARTICLES_PER_RUN=5
AGENT_DEFAULT_TOPICS=news,lifestyle,technology,sports,health,finance

# Application Settings
NODE_ENV=production
NEXT_PUBLIC_APP_URL=https://${config.domain.domain}
`;
}

export function generateNginxConfig(config: DeploymentConfig): string {
  const domain = config.domain.domain;
  const port = 3000;

  // Start with HTTP-only config - Certbot will add SSL automatically
  return `# News Portal - ${config.domain.brandName}
# Generated by Installer
# Note: SSL will be configured by Certbot

server {
    listen 80;
    listen [::]:80;
    server_name ${domain} www.${domain};

    # Security Headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Gzip Compression
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml application/json application/javascript application/rss+xml application/atom+xml image/svg+xml;

    # Static files caching
    location /_next/static {
        proxy_pass http://localhost:${port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    location /images {
        proxy_pass http://localhost:${port};
        expires 30d;
        add_header Cache-Control "public";
    }

    # Proxy to Next.js
    location / {
        proxy_pass http://localhost:${port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 60s;
        proxy_send_timeout 60s;
    }

    # Block sensitive files
    location ~ /\\. {
        deny all;
    }

    location ~ ^/(\\.env|package\\.json|tsconfig\\.json) {
        deny all;
    }
}
`;
}

export function generatePM2Config(config: DeploymentConfig): string {
  const appName = `newsportal-${config.domain.brandId}`;
  
  return `module.exports = {
  apps: [{
    name: '${appName}',
    script: 'npm',
    args: 'start',
    cwd: '${config.server.deployPath}',
    env: {
      NODE_ENV: 'production',
      PORT: 3000
    },
    instances: 1,
    autorestart: true,
    watch: false,
    max_memory_restart: '1G',
    error_file: '${config.server.deployPath}/logs/error.log',
    out_file: '${config.server.deployPath}/logs/output.log',
    merge_logs: true,
    log_date_format: 'YYYY-MM-DD HH:mm:ss Z'
  }]
};
`;
}

export async function deployToServer(
  config: DeploymentConfig,
  onProgress: ProgressCallback
): Promise<void> {
  let currentStep: DeploymentStepId = 'connect';
  
  const ssh = new SSHClient((log) => {
    onProgress({ stepId: currentStep, status: 'running', log });
  });

  const deployPath = config.server.deployPath;
  const brandId = config.domain.brandId;
  const domain = config.domain.domain;
  const email = config.admin.adminEmail;

  try {
    // ============================================
    // Step 1: Connect to Server
    // ============================================
    currentStep = 'connect';
    onProgress({ stepId: 'connect', status: 'running', message: 'Connecting to server...' });
    await ssh.connect(config.server);
    onProgress({ stepId: 'connect', status: 'completed', message: 'Connected successfully' });

    // ============================================
    // Step 2: Prepare System (Fix dpkg, update packages)
    // ============================================
    currentStep = 'prepare';
    onProgress({ stepId: 'prepare', status: 'running', message: 'Preparing system...' });

    // Check if we should skip the apt wait (for re-deployments)
    const skipAptWait = config.server.skipAptWait || false;

    if (!skipAptWait) {
      // Wait for any existing apt/dpkg processes to finish (common on fresh installs)
      onProgress({ stepId: 'prepare', status: 'running', log: 'Checking for running package managers...' });
      
      // Try to stop unattended-upgrades gracefully first
      await ssh.exec('sudo systemctl stop unattended-upgrades 2>/dev/null || true');
      await ssh.exec('sudo systemctl disable unattended-upgrades 2>/dev/null || true');
      
      // Check if apt/dpkg is actually running (exclude grep/pgrep from results)
      const aptRunning = await ssh.exec('ps aux | grep -E "[a]pt-get|[d]pkg" | grep -v grep | head -1');
      
      if (aptRunning.stdout.trim()) {
        onProgress({ stepId: 'prepare', status: 'running', log: 'Package manager is busy, waiting (max 60s)...' });
        
        // Wait max 60 seconds (not 5 minutes)
        for (let i = 0; i < 12; i++) {
          const stillRunning = await ssh.exec('ps aux | grep -E "[a]pt-get|[d]pkg" | grep -v grep | head -1');
          if (!stillRunning.stdout.trim()) {
            onProgress({ stepId: 'prepare', status: 'running', log: 'Package manager is now free' });
            break;
          }
          onProgress({ stepId: 'prepare', status: 'running', log: `Waiting for package manager... (${i * 5}s)` });
          await new Promise(resolve => setTimeout(resolve, 5000));
        }
        
        // Force kill any remaining stuck processes
        await ssh.exec('sudo killall -9 apt apt-get dpkg 2>/dev/null || true');
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    } else {
      onProgress({ stepId: 'prepare', status: 'running', log: 'Skipping apt wait (re-deployment mode)' });
      // Still try to stop unattended-upgrades
      await ssh.exec('sudo systemctl stop unattended-upgrades 2>/dev/null || true');
      await ssh.exec('sudo killall -9 apt apt-get dpkg 2>/dev/null || true');
    }

    // Fix any broken dpkg state FIRST (critical!)
    onProgress({ stepId: 'prepare', status: 'running', log: 'Fixing package manager state...' });
    await ssh.exec('sudo dpkg --configure -a || true');
    await ssh.exec('sudo apt-get clean');
    
    // Update package lists
    onProgress({ stepId: 'prepare', status: 'running', log: 'Updating package lists...' });
    await ssh.exec('sudo apt-get update -y');

    // Install essential packages first
    onProgress({ stepId: 'prepare', status: 'running', log: 'Installing essential packages...' });
    await ssh.exec('sudo apt-get install -y curl wget gnupg2 ca-certificates lsb-release');

    // Check if Node.js is installed and working
    const nodeCheck = await ssh.exec('node --version 2>/dev/null || echo "not found"');
    if (nodeCheck.stdout.includes('not found') || !nodeCheck.stdout.includes('v')) {
      onProgress({ stepId: 'prepare', status: 'running', log: `Installing Node.js ${NODE_VERSION}.x...` });
      
      // Remove any existing Node.js
      await ssh.exec('sudo apt-get remove -y nodejs npm || true');
      await ssh.exec('sudo rm -rf /usr/local/lib/node_modules || true');
      
      // Install Node.js from NodeSource
      await ssh.exec(`curl -fsSL https://deb.nodesource.com/setup_${NODE_VERSION}.x | sudo -E bash -`);
      const nodeInstall = await ssh.exec('sudo apt-get install -y nodejs');
      
      // Verify Node.js installation
      const nodeVerify = await ssh.exec('node --version && npm --version');
      if (!nodeVerify.stdout.includes('v')) {
        throw new Error('Node.js installation failed. Please check server logs.');
      }
      onProgress({ stepId: 'prepare', status: 'running', log: `Node.js installed: ${nodeVerify.stdout.trim()}` });
    } else {
      onProgress({ stepId: 'prepare', status: 'running', log: `Node.js already installed: ${nodeCheck.stdout.trim()}` });
    }

    // Check if Git is installed
    const gitCheck = await ssh.exec('which git || echo "not found"');
    if (gitCheck.stdout.includes('not found')) {
      onProgress({ stepId: 'prepare', status: 'running', log: 'Installing Git...' });
      await ssh.exec('sudo apt-get install -y git');
    }

    onProgress({ stepId: 'prepare', status: 'completed', message: 'System prepared' });

    // ============================================
    // Step 3: Clone/Update Application
    // ============================================
    currentStep = 'upload';
    onProgress({ stepId: 'upload', status: 'running', message: 'Setting up application files...' });

    // Create deploy directory with proper permissions
    await ssh.exec(`sudo mkdir -p ${deployPath}`);
    await ssh.exec(`sudo chown -R $(whoami):$(whoami) ${deployPath}`);

    // Check if repo already exists
    const repoExists = await ssh.exec(`test -d ${deployPath}/.git && echo "exists" || echo "not found"`);
    
    if (repoExists.stdout.includes('exists')) {
      onProgress({ stepId: 'upload', status: 'running', log: 'Updating existing repository...' });
      await ssh.exec('git fetch origin', { cwd: deployPath });
      await ssh.exec('git reset --hard origin/main', { cwd: deployPath });
      await ssh.exec('git pull origin main', { cwd: deployPath });
    } else {
      // Completely remove and recreate the directory to ensure clean clone
      onProgress({ stepId: 'upload', status: 'running', log: 'Preparing clean directory...' });
      await ssh.exec(`sudo rm -rf ${deployPath}`);
      await ssh.exec(`sudo mkdir -p ${deployPath}`);
      await ssh.exec(`sudo chown -R $(whoami):$(whoami) ${deployPath}`);
      
      onProgress({ stepId: 'upload', status: 'running', log: `Cloning from ${REPO_URL}...` });
      
      // Git writes progress to stderr, so we check exit code and look for actual errors
      const cloneResult = await ssh.exec(`git clone --progress ${REPO_URL} ${deployPath} 2>&1`);
      
      // Check for actual failure indicators
      const hasError = cloneResult.exitCode !== 0 || 
                       cloneResult.stdout.includes('fatal:') || 
                       cloneResult.stdout.includes('error:');
      
      if (hasError) {
        // Extract the actual error message
        const errorMatch = cloneResult.stdout.match(/fatal:.*|error:.*/i);
        const errorMsg = errorMatch ? errorMatch[0] : cloneResult.stdout.slice(-200);
        throw new Error(`Git clone failed: ${errorMsg}`);
      }
      
      onProgress({ stepId: 'upload', status: 'running', log: 'Repository cloned successfully' });
    }

    // Verify package.json exists
    const packageCheck = await ssh.exec(`test -f ${deployPath}/package.json && echo "exists" || echo "not found"`);
    if (packageCheck.stdout.includes('not found')) {
      throw new Error('Repository cloned but package.json not found. Check repository structure.');
    }

    onProgress({ stepId: 'upload', status: 'completed', message: 'Application files ready' });

    // ============================================
    // Step 4: Configure Environment
    // ============================================
    currentStep = 'env';
    onProgress({ stepId: 'env', status: 'running', message: 'Configuring environment...' });

    const envContent = generateEnvFile(config);
    await ssh.uploadFile(envContent, `${deployPath}/.env`);
    await ssh.uploadFile(envContent, `${deployPath}/.env.local`);

    // Create brand assets directory
    await ssh.exec(`mkdir -p ${deployPath}/public/images/brands/${brandId}`);

    // Create placeholder logo
    const placeholderLogo = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 50">
  <text x="10" y="35" font-family="Arial, sans-serif" font-size="24" font-weight="bold" fill="${config.domain.primaryColor}">
    ${config.domain.brandName}
  </text>
</svg>`;
    await ssh.uploadFile(placeholderLogo, `${deployPath}/public/images/brands/${brandId}/logo.svg`);

    // Create logs directory
    await ssh.exec(`mkdir -p ${deployPath}/logs`);

    onProgress({ stepId: 'env', status: 'completed', message: 'Environment configured' });

    // ============================================
    // Step 5: Install Dependencies
    // ============================================
    currentStep = 'deps';
    onProgress({ stepId: 'deps', status: 'running', message: 'Installing dependencies...' });

    // Clear npm cache to avoid issues
    await ssh.exec('npm cache clean --force || true');

    // Install project dependencies (not production only - need devDeps for build)
    onProgress({ stepId: 'deps', status: 'running', log: 'Running npm install (this may take a few minutes)...' });
    const npmInstall = await ssh.exec('npm install', { cwd: deployPath });
    
    if (npmInstall.exitCode !== 0 && !npmInstall.stdout.includes('added')) {
      onProgress({ stepId: 'deps', status: 'running', log: `npm install warning: ${npmInstall.stderr}` });
    }

    // Install PM2 globally if not present
    const pm2Check = await ssh.exec('which pm2 || echo "not found"');
    if (pm2Check.stdout.includes('not found')) {
      onProgress({ stepId: 'deps', status: 'running', log: 'Installing PM2 globally...' });
      await ssh.exec('sudo npm install -g pm2');
      
      // Verify PM2 installation - check for version number in output (PM2 prints banner + version)
      const pm2Verify = await ssh.exec('pm2 --version 2>&1 | tail -1');
      // PM2 outputs a lot of ASCII art, then the version number on the last line
      if (!pm2Verify.stdout.match(/\d+\.\d+\.\d+/)) {
        throw new Error('PM2 installation failed - could not verify version');
      }
      onProgress({ stepId: 'deps', status: 'running', log: `PM2 installed: v${pm2Verify.stdout.trim()}` });
    }

    onProgress({ stepId: 'deps', status: 'completed', message: 'Dependencies installed' });

    // ============================================
    // Step 6: Build Application
    // ============================================
    currentStep = 'build';
    onProgress({ stepId: 'build', status: 'running', message: 'Building application (this may take several minutes)...' });

    const buildResult = await ssh.exec('npm run build', { cwd: deployPath });
    
    // Check if build was successful
    if (buildResult.exitCode !== 0) {
      throw new Error(`Build failed: ${buildResult.stderr}`);
    }

    // Verify .next directory exists
    const nextCheck = await ssh.exec(`test -d ${deployPath}/.next && echo "exists" || echo "not found"`);
    if (nextCheck.stdout.includes('not found')) {
      throw new Error('Build completed but .next directory not found');
    }

    // Create PM2 ecosystem file
    const pm2Config = generatePM2Config(config);
    await ssh.uploadFile(pm2Config, `${deployPath}/ecosystem.config.js`);

    onProgress({ stepId: 'build', status: 'completed', message: 'Build successful' });

    // ============================================
    // Step 7: Configure Nginx
    // ============================================
    currentStep = 'nginx';
    onProgress({ stepId: 'nginx', status: 'running', message: 'Configuring web server...' });

    // Install Nginx if not present
    const nginxCheck = await ssh.exec('which nginx || echo "not found"');
    if (nginxCheck.stdout.includes('not found')) {
      onProgress({ stepId: 'nginx', status: 'running', log: 'Installing Nginx...' });
      await ssh.exec('sudo apt-get install -y nginx');
    }

    // Ensure Nginx directories exist
    await ssh.exec('sudo mkdir -p /etc/nginx/sites-available /etc/nginx/sites-enabled');

    // Upload Nginx config
    const nginxConfig = generateNginxConfig(config);
    await ssh.uploadFile(nginxConfig, `/tmp/newsportal-${brandId}.conf`);
    await ssh.exec(`sudo mv /tmp/newsportal-${brandId}.conf /etc/nginx/sites-available/newsportal-${brandId}`);
    await ssh.exec(`sudo ln -sf /etc/nginx/sites-available/newsportal-${brandId} /etc/nginx/sites-enabled/`);

    // Remove default site
    await ssh.exec('sudo rm -f /etc/nginx/sites-enabled/default || true');

    // Test Nginx configuration
    const nginxTest = await ssh.exec('sudo nginx -t 2>&1');
    if (nginxTest.exitCode !== 0) {
      onProgress({ stepId: 'nginx', status: 'running', log: `Nginx config warning: ${nginxTest.stderr}` });
    }

    // Start/Reload Nginx
    await ssh.exec('sudo systemctl enable nginx');
    await ssh.exec('sudo systemctl start nginx || sudo systemctl reload nginx');

    onProgress({ stepId: 'nginx', status: 'completed', message: 'Nginx configured' });

    // ============================================
    // Step 8: Setup SSL Certificate
    // ============================================
    currentStep = 'ssl';
    onProgress({ stepId: 'ssl', status: 'running', message: 'Setting up SSL certificate...' });

    // Install Certbot if not present
    const certbotCheck = await ssh.exec('which certbot || echo "not found"');
    if (certbotCheck.stdout.includes('not found')) {
      onProgress({ stepId: 'ssl', status: 'running', log: 'Installing Certbot...' });
      await ssh.exec('sudo apt-get install -y certbot python3-certbot-nginx');
    }

    // Get SSL certificate
    onProgress({ stepId: 'ssl', status: 'running', log: `Obtaining SSL certificate for ${domain}...` });
    const certResult = await ssh.exec(
      `sudo certbot --nginx -d ${domain} -d www.${domain} --non-interactive --agree-tos -m ${email} --redirect 2>&1 || echo "CERTBOT_WARNING"`
    );

    if (certResult.stdout.includes('CERTBOT_WARNING') || certResult.stdout.includes('error')) {
      onProgress({ stepId: 'ssl', status: 'running', log: 'SSL setup note: Certificate may require DNS propagation. Site will work on HTTP.' });
    } else {
      onProgress({ stepId: 'ssl', status: 'running', log: 'SSL certificate installed successfully' });
    }

    onProgress({ stepId: 'ssl', status: 'completed', message: 'SSL configured' });

    // ============================================
    // Step 9: Start Application
    // ============================================
    currentStep = 'start';
    onProgress({ stepId: 'start', status: 'running', message: 'Starting application...' });

    const appName = `newsportal-${brandId}`;

    // Stop any existing PM2 processes
    await ssh.exec(`pm2 stop ${appName} 2>/dev/null || true`);
    await ssh.exec(`pm2 delete ${appName} 2>/dev/null || true`);

    // Start application with PM2
    onProgress({ stepId: 'start', status: 'running', log: 'Starting application with PM2...' });
    const startResult = await ssh.exec(`cd ${deployPath} && pm2 start ecosystem.config.js`);
    
    if (startResult.exitCode !== 0) {
      throw new Error(`Failed to start application: ${startResult.stderr}`);
    }

    // Save PM2 configuration
    await ssh.exec('pm2 save');

    // Setup PM2 to start on boot
    onProgress({ stepId: 'start', status: 'running', log: 'Configuring PM2 startup...' });
    const startupCmd = await ssh.exec('pm2 startup systemd -u root --hp /root 2>&1 | grep "sudo" || echo ""');
    if (startupCmd.stdout.includes('sudo')) {
      await ssh.exec(startupCmd.stdout.trim());
    }

    // Verify application is running
    const pm2Status = await ssh.exec('pm2 jlist');
    if (!pm2Status.stdout.includes(appName)) {
      onProgress({ stepId: 'start', status: 'running', log: 'Warning: Application may not be running. Check PM2 logs.' });
    }

    onProgress({ stepId: 'start', status: 'completed', message: 'Application started' });

    // ============================================
    // Deployment Complete
    // ============================================
    onProgress({
      stepId: 'start',
      status: 'completed',
      message: 'Deployment complete!',
      complete: true,
      log: `
========================================
Deployment Successful!
========================================
Application URL: https://${domain}
Admin Panel: https://${domain}/admin

Useful Commands (SSH into server):
  pm2 status              - Check app status
  pm2 logs ${appName}     - View logs
  pm2 restart ${appName}  - Restart app
  
If SSL is not working, wait for DNS propagation
and run: sudo certbot --nginx -d ${domain}
========================================
      `.trim()
    });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Deployment failed';
    onProgress({
      stepId: currentStep,
      status: 'error',
      error: errorMessage,
      complete: true
    });
    throw error;
  } finally {
    ssh.disconnect();
  }
}
