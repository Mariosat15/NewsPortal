import { SSHClient } from './ssh-client';
import { DeploymentConfig } from './types';

// GitHub repo URL for cloning
const REPO_URL = 'https://github.com/Mariosat15/NewsPortal.git';

export type DeploymentStepId = 'connect' | 'upload' | 'env' | 'deps' | 'build' | 'nginx' | 'ssl' | 'start';

export interface StepUpdate {
  stepId: DeploymentStepId;
  status: 'running' | 'completed' | 'error';
  message?: string;
  log?: string;
  complete?: boolean;
  error?: string;
}

type ProgressCallback = (update: StepUpdate) => void;

export function generateEnvFile(config: DeploymentConfig): string {
  return `# ============================================
# NEWS PORTAL - ${config.domain.brandName}
# Brand ID: ${config.domain.brandId}
# Generated by Installer: ${new Date().toISOString()}
# ============================================

# Brand Configuration
BRAND_ID=${config.domain.brandId}
BRAND_NAME="${config.domain.brandName}"
BRAND_DOMAIN=${config.domain.domain}
BRAND_LOGO_URL=/images/brands/${config.domain.brandId}/logo.svg
BRAND_PRIMARY_COLOR=${config.domain.primaryColor}
BRAND_SECONDARY_COLOR=${config.domain.secondaryColor}

# MongoDB
MONGODB_URI=${config.database.mongodbUri}

# Authentication
BETTER_AUTH_SECRET=${config.admin.authSecret}
BETTER_AUTH_URL=https://${config.domain.domain}

# DIMOCO Payment
DIMOCO_API_URL=${config.payment.dimocoApiUrl}
DIMOCO_API_KEY=${config.payment.dimocoApiKey}
DIMOCO_MERCHANT_ID=${config.payment.dimocoMerchantId}
DIMOCO_SERVICE_ID=${config.payment.dimocoServiceId}
DIMOCO_CALLBACK_SECRET=${config.payment.dimocoCallbackSecret}
DIMOCO_SUCCESS_URL=https://${config.domain.domain}/payment/success
DIMOCO_CANCEL_URL=https://${config.domain.domain}/payment/cancel

# Article pricing
ARTICLE_PRICE_CENTS=${config.payment.articlePriceCents}

# OpenAI
OPENAI_API_KEY=${config.apiKeys.openaiApiKey}

# BrightData (optional)
${config.apiKeys.brightdataToken ? `BRIGHTDATA_API_TOKEN=${config.apiKeys.brightdataToken}` : '# BRIGHTDATA_API_TOKEN='}
${config.apiKeys.brightdataZone ? `BRIGHTDATA_ZONE=${config.apiKeys.brightdataZone}` : '# BRIGHTDATA_ZONE=web_unlocker1'}

# Admin Configuration
ADMIN_EMAIL=${config.admin.adminEmail}
ADMIN_PASSWORD=${config.admin.adminPassword}
ADMIN_SECRET=${config.admin.adminSecret}

# Agent Configuration
AGENT_CRON_SCHEDULE=0 */6 * * *
AGENT_MAX_ARTICLES_PER_RUN=5
AGENT_DEFAULT_TOPICS=news,lifestyle,technology,sports,health,finance

# Application Settings
NODE_ENV=production
NEXT_PUBLIC_APP_URL=https://${config.domain.domain}
`;
}

export function generateNginxConfig(config: DeploymentConfig): string {
  const domain = config.domain.domain;
  const port = 3000;

  // Start with HTTP-only config - Certbot will add SSL automatically
  return `# News Portal - ${config.domain.brandName}
# Generated by Installer
# Note: SSL will be configured by Certbot

server {
    listen 80;
    listen [::]:80;
    server_name ${domain} www.${domain};

    # Security Headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Gzip Compression
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml application/json application/javascript application/rss+xml application/atom+xml image/svg+xml;

    # Static files caching
    location /_next/static {
        proxy_pass http://localhost:${port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    location /images {
        proxy_pass http://localhost:${port};
        expires 30d;
        add_header Cache-Control "public";
    }

    # Proxy to Next.js
    location / {
        proxy_pass http://localhost:${port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 60s;
        proxy_send_timeout 60s;
    }

    # Block sensitive files
    location ~ /\\. {
        deny all;
    }

    location ~ ^/(\\.env|package\\.json|tsconfig\\.json) {
        deny all;
    }
}
`;
}

export function generatePM2Config(config: DeploymentConfig): string {
  const appName = `newsportal-${config.domain.brandId}`;
  
  return `module.exports = {
  apps: [{
    name: '${appName}',
    script: 'npm',
    args: 'start',
    cwd: '${config.server.deployPath}',
    env: {
      NODE_ENV: 'production',
      PORT: 3000
    },
    instances: 1,
    autorestart: true,
    watch: false,
    max_memory_restart: '1G',
    error_file: '${config.server.deployPath}/logs/error.log',
    out_file: '${config.server.deployPath}/logs/output.log',
    merge_logs: true,
    log_date_format: 'YYYY-MM-DD HH:mm:ss Z'
  }]
};
`;
}

export async function deployToServer(
  config: DeploymentConfig,
  onProgress: ProgressCallback
): Promise<void> {
  const ssh = new SSHClient((log) => {
    onProgress({ stepId: 'connect', status: 'running', log });
  });

  const deployPath = config.server.deployPath;
  const brandId = config.domain.brandId;

  try {
    // Step 1: Connect
    onProgress({ stepId: 'connect', status: 'running', message: 'Connecting to server...' });
    await ssh.connect(config.server);
    onProgress({ stepId: 'connect', status: 'completed', message: 'Connected successfully' });

    // Step 2: Upload/Clone application
    onProgress({ stepId: 'upload', status: 'running', message: 'Setting up application...' });
    
    // Check if Node.js is installed
    const nodeCheck = await ssh.exec('which node || echo "not found"');
    if (nodeCheck.stdout.includes('not found')) {
      onProgress({ stepId: 'upload', status: 'running', log: 'Installing Node.js...' });
      await ssh.exec('curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -');
      await ssh.exec('sudo apt-get install -y nodejs');
    }

    // Check if git is installed
    const gitCheck = await ssh.exec('which git || echo "not found"');
    if (gitCheck.stdout.includes('not found')) {
      onProgress({ stepId: 'upload', status: 'running', log: 'Installing git...' });
      await ssh.exec('sudo apt-get update && sudo apt-get install -y git');
    }

    // Create deploy directory
    await ssh.exec(`sudo mkdir -p ${deployPath}`);
    await ssh.exec(`sudo chown -R $USER:$USER ${deployPath}`);

    // Clone or pull repository
    const repoExists = await ssh.exists(`${deployPath}/.git`);
    if (repoExists) {
      onProgress({ stepId: 'upload', status: 'running', log: 'Updating existing installation...' });
      await ssh.exec(`git pull`, { cwd: deployPath });
    } else {
      onProgress({ stepId: 'upload', status: 'running', log: 'Cloning repository...' });
      // For now, we'll create a placeholder since repo URL needs to be configured
      await ssh.exec(`git clone ${REPO_URL} ${deployPath} || echo "Clone failed - manual upload may be needed"`);
    }
    
    onProgress({ stepId: 'upload', status: 'completed', message: 'Application files ready' });

    // Step 3: Configure environment
    onProgress({ stepId: 'env', status: 'running', message: 'Generating configuration...' });
    
    const envContent = generateEnvFile(config);
    await ssh.uploadFile(envContent, `${deployPath}/.env`);
    await ssh.uploadFile(envContent, `${deployPath}/.env.local`);
    
    // Create brand assets directory
    await ssh.exec(`mkdir -p ${deployPath}/public/images/brands/${brandId}`);
    
    // Create placeholder logo
    const placeholderLogo = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 50">
  <text x="10" y="35" font-family="Arial, sans-serif" font-size="24" font-weight="bold" fill="${config.domain.primaryColor}">
    ${config.domain.brandName}
  </text>
</svg>`;
    await ssh.uploadFile(placeholderLogo, `${deployPath}/public/images/brands/${brandId}/logo.svg`);
    
    onProgress({ stepId: 'env', status: 'completed', message: 'Environment configured' });

    // Step 4: Install dependencies
    onProgress({ stepId: 'deps', status: 'running', message: 'Installing dependencies...' });
    await ssh.exec('npm install --production', { cwd: deployPath });
    
    // Install PM2 globally if not present
    const pm2Check = await ssh.exec('which pm2 || echo "not found"');
    if (pm2Check.stdout.includes('not found')) {
      onProgress({ stepId: 'deps', status: 'running', log: 'Installing PM2...' });
      await ssh.exec('sudo npm install -g pm2');
    }
    
    onProgress({ stepId: 'deps', status: 'completed', message: 'Dependencies installed' });

    // Step 5: Build application
    onProgress({ stepId: 'build', status: 'running', message: 'Building application...' });
    await ssh.exec('npm run build', { cwd: deployPath });
    
    // Create logs directory
    await ssh.exec(`mkdir -p ${deployPath}/logs`);
    
    // Create PM2 ecosystem file
    const pm2Config = generatePM2Config(config);
    await ssh.uploadFile(pm2Config, `${deployPath}/ecosystem.config.js`);
    
    onProgress({ stepId: 'build', status: 'completed', message: 'Build successful' });

    // Step 6: Configure Nginx
    onProgress({ stepId: 'nginx', status: 'running', message: 'Configuring web server...' });
    
    // Check if Nginx is installed
    const nginxCheck = await ssh.exec('which nginx || echo "not found"');
    if (nginxCheck.stdout.includes('not found')) {
      onProgress({ stepId: 'nginx', status: 'running', log: 'Installing Nginx...' });
      await ssh.exec('sudo apt-get update && sudo apt-get install -y nginx');
    }

    const nginxConfig = generateNginxConfig(config);
    await ssh.uploadFile(nginxConfig, `/tmp/newsportal-${brandId}.conf`);
    await ssh.exec(`sudo mv /tmp/newsportal-${brandId}.conf /etc/nginx/sites-available/newsportal-${brandId}`);
    await ssh.exec(`sudo ln -sf /etc/nginx/sites-available/newsportal-${brandId} /etc/nginx/sites-enabled/`);
    
    // Remove default site if exists
    await ssh.exec('sudo rm -f /etc/nginx/sites-enabled/default || true');
    
    // Test and reload Nginx
    await ssh.exec('sudo nginx -t');
    await ssh.exec('sudo systemctl reload nginx');
    
    onProgress({ stepId: 'nginx', status: 'completed', message: 'Nginx configured' });

    // Step 7: Setup SSL
    onProgress({ stepId: 'ssl', status: 'running', message: 'Setting up SSL certificate...' });
    
    // Install certbot if not present
    const certbotCheck = await ssh.exec('which certbot || echo "not found"');
    if (certbotCheck.stdout.includes('not found')) {
      onProgress({ stepId: 'ssl', status: 'running', log: 'Installing Certbot...' });
      await ssh.exec('sudo apt-get install -y certbot python3-certbot-nginx');
    }

    // Get SSL certificate
    const domain = config.domain.domain;
    const email = config.admin.adminEmail;
    await ssh.exec(`sudo certbot --nginx -d ${domain} -d www.${domain} --non-interactive --agree-tos -m ${email} || echo "SSL setup may require DNS configuration"`);
    
    onProgress({ stepId: 'ssl', status: 'completed', message: 'SSL configured' });

    // Step 8: Start application
    onProgress({ stepId: 'start', status: 'running', message: 'Starting application...' });
    
    // Stop existing PM2 process if running
    const appName = `newsportal-${brandId}`;
    await ssh.exec(`pm2 stop ${appName} || true`);
    await ssh.exec(`pm2 delete ${appName} || true`);
    
    // Start with PM2
    await ssh.exec('pm2 start ecosystem.config.js', { cwd: deployPath });
    await ssh.exec('pm2 save');
    
    // Setup PM2 startup
    await ssh.exec('pm2 startup || true');
    
    onProgress({ stepId: 'start', status: 'completed', message: 'Application started' });

    // Complete
    onProgress({ 
      stepId: 'start', 
      status: 'completed', 
      message: 'Deployment complete!',
      complete: true,
      log: `Application deployed to https://${domain}`
    });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Deployment failed';
    onProgress({ 
      stepId: 'connect', 
      status: 'error', 
      error: errorMessage,
      complete: true 
    });
    throw error;
  } finally {
    ssh.disconnect();
  }
}
